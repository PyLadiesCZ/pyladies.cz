<html>

    <head>
        <meta charset="utf-8">
        <title>PyLadies 06-03 – Seznamy</title>

        <link rel="stylesheet" href="../css/bootstrap.css">
        <link rel="stylesheet" href="../css/pyladies.css">
        <style>
            .new { background-color: #fee; margin: -10px -1000px; padding: 10px 1000px; }
        </style>
    </head>

    <body class="no-reveal">

        <div class="container">
            <div class="no-reveal header">
                <h3 class="text-muted" id="show-all">PyLadies Brno</h3>
            </div>
            <div class="slides row stuff">
                <section class="col-lg-12">
                    <section class="new">
                        <div>
                            Takto jsou zvýrazněny části, které jsem srazu
                            prosvištěl příliš rychle; obsahují nové příklady
                            a snad i lepší vysvětlení důsledků.
                        </div>
                    </section>
                    <section>
                        <h1>Seznamy</h1>
                        <div>
                            Dnes si ukážeme, jak pracovat se <em>seznamy</em>
                            (angl. <em>lists</em>).
                            Doufám že víš, kde máš na klávesnici hranaté
                            závorky, protože právě těmi se seznamy vytváří:
                        </div>
<pre>
fibonacciho_cisla = [1, 1, 2, 3, 5, 8, 13]
print(fibonacciho_cisla)
</pre>
                        <div>
                            Seznam je hodnota, která může obsahovat spoustu
                            dalších hodnot.
                            Tak jako řetězec obsahuje sekvenci znaků,
                            seznam obsahuje sekvenci jakýchkoli hodnot.
                            A tak jako můžeme pomocí cyklu <code>for</code>
                            procházet řetězec po znacích,
                            seznam můžeme procházet po jednotlivých prvcích:
                        </div>
<pre>
for cislo in fibonacciho_cisla:
    print(cislo)
</pre>
                        <div>
                            Seznamy se v programech vyskytují velice často:
                            soubor se dá načíst jako seznam řetězců
                            s jednotlivými řádky,
                            seznam řetězců jako <code>'7♥'</code>
                            a <code>'K♣'</code> poslouží jako balíček karet,
                            matematika je plná číselných řad,
                            každá online služba má seznam uživatelů.
                        </div>
                        <div>
                            Hodnoty v seznamu můžou být jakéhokoli typu,
                            dokonce můžeme různé typy míchat v jednom seznamu
                            (i když s takovými namixovanými seznamy se
                            příliš často nesetkáme):
                        </div>
<pre>
seznam = [1, 'abc', True, None, range(10), len]
print(seznam)
</pre>
                        <h2>Vybírání ze seznamů</h2>
                        <div>
                            Nejzákladnější operaci se seznamy,
                            cyklus <code>for</code>, už jsme si ukázaly;
                            druhá nejdůležitější operace je vybírání
                            prvků seznamu.
                            To funguje jako u řetězců: do hranatých závorek
                            se dá číslo prvku. Čísluje se, jako u řetězců,
                            od nuly; záporná čísla označují prvky od konce.
                        </div>
<pre>
print(fibonacciho_cisla[2])
</pre>
                        <div>
                            Hranatými závorkami můžeme získávat podseznamy.
                            <a href="../s004-strings/strings.html#slicing-diagram">
                                Diagram z materiálů k řetězcům
                            </a>
                            ukazuje, jak u takového „sekání” číslovat;
                            funguje to stejně, jen místo menšího řetězce
                            dostaneme menší seznam.
                        </div>
<pre>
print(fibonacciho_cisla[2:-3])
</pre>
                        <section class="new">
                        <h2>Měnění seznamů</h2>
                        <div>
                            Důležitá vlastnost seznamů,
                            kterou nemají ani čísla, ani řetězce
                            (a True/False/None už vůbec ne), je,
                            že seznamy se dají měnit.
                        </div>
                        <div>
                            Čísla měnit nejdou – máme-li <code>a = 3</code> a
                            napíšeme <code>a = a + 1</code>;
                            číslo <code>3</code> se nezmění.
                            Vypočítá se nové
                            číslo <code>4</code> a proměnná <code>a</code>
                            se nastaví na toto nové číslo.
                        </div>
                        <div>
                            Oproti tomu seznamy se dají měnit bez nastavování
                            proměnné.
                            Základní způsob, jak změnit seznam, je přidání
                            prvku na konec pomocí metody <code>append</code>.
                            Ta <em>nic nevrací</em> (resp. vrací None),
                            ale „na místě” (angl. <em>in place</em>) změní
                            seznam, na kterém pracuje:
                        </div>
<pre>
prvocisla = [2, 3, 5, 7, 11, 13, 17]
print(prvocisla)
prvocisla.append(19)
print(prvocisla)
</pre>
                        <div>
                            Takové měnění hodnoty může být občas překvapující,
                            protože stejnou hodnotu může mít více proměnných.
                            Protože se mění hodnota samotná, můžeme „změnit
                            proměnnou” aniž na ni „sáhneme”:
                        </div>
<pre>
a = [1, 2, 3]
b = a

print(b)
a.append(4)
print(b)
</pre>
                        </section> <!-- new -->
                        <h2>Další způsoby, jak měnit seznamy</h2>
                        <div>
                            Kromě metody <code>append</code>, která přidává
                            jediný prvek, existuje metoda <code>extend</code>,
                            která umí přidávat prvků víc.
                            Prvky k přidání ji předáme ve formě seznamu:
                        </div>
<pre>
dalsi_prvocisla = [23, 29, 31]
prvocisla.extend(dalsi_prvocisla)
print(prvocisla)
</pre>
                        <div>
                            Metoda <code>extend</code> umí pracovat i s jinými
                            typy než se seznamy – ráda zpracuje cokoli, přes
                            co umí cykilt <code>for</code>, tedy např.
                            jednotlivé znaky řetězců, řádky souborů, nebo čísla
                            z <code>range()</code>.
                        </div>
<pre>
seznam = []
seznam.extend('abcdef')
seznam.extend(range(10))
print(seznam)
</pre>
                        <h3>Měnění prvků</h3>
                        <div>
                            Ale dost přidávání.
                            Seznamům se dají i měnit jednotlivé prvky,
                            a to jednoduše tak, že do prvku přiřadíme
                            jako by to byla proměnná:
                        </div>
<pre>
cisla = [1, 0, 3, 4]
cisla[1] = 2
print(cisla)
</pre>
                        <div>
                            Přiřazovat se dá i do podseznamu – v tomto případě
                            se podseznam nahradí jednotlivými prvky z toho,
                            co přiřazujeme.
                            Jako u <code>extend</code>,
                            do podseznamu můžeme opět přiřadit cokoli, co umí
                            zpracovat <code>for</code> – seznam, řetězec,
                            <code>range()</code> apod.
                        </div>
<pre>
cisla = [1, 2, 3, 4]
cisla[1:-1] = [6, 5]
print(cisla)
</pre>
                        <h3>Mazání prvků</h3>
                        <div>
                            Přiřazením do podseznamu se dá i změnit délka
                            seznamu, nebo některé prvky úplně odstranit:
                        </div>
<pre>
cisla = [1, 2, 3, 4]
cisla[1:-1] = [0, 0, 0, 0, 0, 0]
print(cisla)
cisla[1:-1] = []
print(cisla)
</pre>
                        <div>
                            Tenhle zápis pro mazání prvků je ale docela
                            nepřehledný, a proto na to máme zvláštní příkaz
                            jménem <code>del</code>.
                            Jak už jeho název (z angl. <em>delete</em>, smazat)
                            napovídá, smaže, co mu přijde pod ruku – jednotlivé
                            prvky seznamů, podseznamy, … a dokonce i proměnné.
                        </div>
<pre>
cisla = [1, 2, 3, 4, 5, 6]
del cisla[-1]
print(cisla)
del cisla[3:5]
print(cisla)
del cisla
print(cisla)
</pre>
                        <div>
                            Další mazací metody jsou:
                            <ul>
                                <li>
                                    <code>pop</code>, která odstraní <em>a vrátí</em>
                                    poslední prvek v seznamu – například pokud
                                    mám seznam karet v balíčku, jde takhle
                                    jednoduše „líznout” kartu,
                                </li>
                                <li>
                                    <code>remove</code>, která najde v seznamu
                                    daný prvek a odstraní ho,
                                </li>
                                <li>
                                    <code>clear</code>, která vyprázdní celý
                                    seznam.
                                </li>
                            </ul>
                        </div>
<pre>
cisla = [1, 2, 3, 'abc', 4, 5, 6, 12]
posledni = cisla.pop()
print(posledni)
print(cisla)

cisla.remove('abc')
print(cisla)

cisla.clear()
print(cisla)
</pre>
                        <section class="new">
                        <h3>Řazení</h3>
                        <div>
                            A taky tu máme metodu <code>sort</code>,
                            která prvky seznamu seřadí.
                        </div>
<pre>
seznam = [4, 7, 8, 3, 5, 2, 4, 8, 5]
seznam.sort()
print(seznam)
</pre>
                        <div>
                            Aby se daly seřadit, musí být prvky seznamu
                            porovnatelné – konktrétně na ně musí fungovat
                            operátor <code>&lt;</code>.
                            Seznam s mixem čísel a řetězců tedy
                            seřadit nepůjde.
                            Operátor <code>&lt;</code> definuje i
                            jak přesně se řadí (např. čísla podle velikosti;
                            řetězce podle speciální „abecedy” která řadí
                            velká písmena za malá, česká až za anglická, atd.).
                        </div>
                        <div>
                            Metoda <code>sort</code> zná pojmenovaný argument
                            <code>reverse</code>. Pokud ho nastavíme
                            na <em>true</em>, řadí se „naopak”.
                        </div>
<pre>
seznam = [4, 7, 8, 3, 5, 2, 4, 8, 5]
seznam.sort(reverse=True)
print(seznam)
</pre>
                        </section>
                        <h2>Známé operace se seznamy</h2>
                        <div>
                            Spousta toho, co můžeme dělat s řetězci, má stejný
                            účinek i u seznamů.
                            Třeba sečítání a násobení číslem:
                        </div>
<pre>
melodie = ['C', 'E', 'G'] * 2 + ['E', 'E', 'D', 'E', 'F', 'D'] * 2 + ['E', 'D', 'C']
print(melodie)
</pre>
                        <div>
                            Stejně jako u řetězců, sečítat jde jen seznam
                            se seznamem – ne třeba seznam s řetězcem.
                        </div>
                        <div>
                            Další staří známí jsou funkce <code>len</code>,
                            metody <code>count</code> a <code>index</code>,
                            a operátor <code>in</code>.
                        </div>
<pre>
print(len(melodie))         # Délka seznamu
print(melodie.count('D'))   # Počet 'D' v seznamu
print(melodie.index('D'))   # Číslo prvního 'D'
print('D' in melodie)       # Je 'D' v seznamu?
</pre>
                        <div>
                            Poslední tři se ale přece jen chovají kapku jinak:
                            u řetězců pracují s <em>podřetězci</em>,
                            u seznamů jen s <em>jednotlivými</em> prvky.
                            Takže ačkoliv naše melodie obsahuje prvky
                            <code>'D'</code> a <code>'E'</code>
                            vedle sebe, <code>'DE'</code> v seznamu není:
                        </div>
<pre>
print('DE' in melodie)
print(melodie.count('DE'))
print(melodie.index('DE'))
</pre>
                        <h2>Seznam jako podmínka</h2>
                        <div>
                            Seznam se dá použít v příkazu <code>if</code>
                            (nebo <code>while</code>) jako podmínka,
                            která platí když v tom seznamu něco je.
                            Jinými slovy, <code>seznam</code> je tu zkratka pro
                            <code>len(seznam) &gt; 0</code>.
                        </div>
<pre>
if seznam:
    print('V seznamu něco je!')
else:
    print('Seznam je prázdný!')
</pre>
                        <div class="new">
                            Podobně se dají v podmínce použít i řetězce.
                            A dokonce i čísla –
                            ty jako podmínka platí, pokud jsou nenulová.
                        </div>
                        <h2>Tvoření seznamů</h2>
                        <div>
                            Tak jako funkce <code>int</code> převádí na
                            celá čísla a <code>str</code> na řetězce,
                            funkce <code>list</code> (angl. <em>seznam</em>)
                            převádí na seznam.
                            Jako argument jí předáme jakoukoli hodnotu,
                            kterou umí zpracovat příkaz <code>for</code>.
                            Z řetězců udělá seznam znaků, z otevřeného souboru
                            udělá seznam řádků, z <code>range</code> udělá
                            seznam čísel.
                        </div>
<pre>
abeceda = list('abcdefghijklmnopqrstuvwxyz')
cisla = list(range(100))
print(abeceda)
print(cisla)
</pre>
                        <section class="new">
                        <div>
                            I ze seznamu udělá funkce <code>list</code> seznam.
                            To může znít zbytečně, ale není – vytvoří se
                            totiž <em>nový</em> seznam.
                            Bude mít sice stejné prvky ve stejném pořadí,
                            ale nebude to ten samý seznam:
                            měnit se bude nezávisle na tom starém.
                        </div>
<pre>
a = [1, 2, 3]
b = list(a)

print(b)
a.append(4)
print(b)
</pre>
                        </section>
                        <div>
                            Další způsob, jak tvořit seznamy
                            (zvláště složitější), je nejdřív udělat prázdný
                            seznam, a pak ho postupně naplnit pomocí funkce
                            <code>append</code>.
                            Třeba pokud z nějakého důvodu chceš seznam
                            mocnin dvou, projdi čísla kterými chceme mocnit
                            cyklem <code>for</code>, a pro každé z nich
                            do seznamu přidej příslušnou mocninu:
                        </div>
<pre>
mocniny_dvou = []
for cislo in range(10):
    mocniny_dvou.append(2 ** cislo)
print(mocniny_dvou)
</pre>
                        <div>
                            Chceš-li seznam, který reprezentuje balíček karet,
                            zavolej <code>append</code> pro všechny kombinace
                            barev a hodnot.
                        </div>
<pre>
balicek = []
for barva in '♠', '♥', '♦', '♣':
    for hodnota in list(range(2, 11)) + ['J', 'Q', 'K', 'A']:
        balicek.append(str(hodnota) + barva)
print(balicek)
</pre>
                        <h2>Seznamy a řetězce</h2>
                        <div>
                            Seznamy a řetězce jsou druhy „sekvencí”,
                            takže snad nepřekvapí, že se dá různě převádět
                            z jednoho typu na druhý.
                            Funkce <code>list</code> vytvoří z řetězce
                            seznam znaků.
                            Když chceme dostat seznam slov, použijeme
                            na řetězci metodu <code>split</code>
                            (angl. <em>rozdělit</em>):
                        </div>
<pre>
slova = 'Tato věta je složitá, rozdělme ji na slova!'.split()
print(slova)
</pre>
                        <div>
                            Metoda <code>split</code> umí brát i argument.
                            Pokud ho předáme, místo mezer (a nových řádků)
                            se řetězec „rozseká” daným oddělovačem.
                            Takže když máme nějaká data oddělená čárkami,
                            není nic jednoduššího než použít <code>split</code>
                            s čárkou:
                        </div>
<pre>
zaznamy = '3A,8B,2X,9D'.split(',')
print(zaznamy)
</pre>
                        <div>
                            Chceme-li spojit seznam řetězců zase dohromady,
                            do jediného řetězce, použijeme metodu
                            <code>join</code> (angl. <em>spojit</em>).
                            Pozor, tahle metoda se volá na <em>oddělovači</em>,
                            tedy řetězci, kterým se jednotlivé kousky „slepí”
                            dohromady; a jako argument bere seznam jednotlivých
                            řetězců.
                        </div>
<pre>
veta = ' '.join(slova)
print(veta)
</pre>
                        <h2>Úkol</h2>
                        <div>
                            Některé z vás pro 1-D piškvorky udělali funkci
                            <code>tah_pocitace</code>, která umí hrát jen
                            za křížky.
                            Takové funkce se nedají přímo použít v turnaji,
                            kde jeden z hráčů musí hrát za kolečka.
                        </div>
                        <div>
                            Jedno z možných řešení je napsat funkci, která
                            zamění v řetězci všechna <code>'x'</code> za
                            <code>'o'</code> a naopak.
                        </div>
<pre>
print(zamen_xo('---xo--xooxxox-'))  <span class="comment"># → '---ox--oxxooxo-'</span>
</pre>
                        <div>
                            Pak se dá napsat funkce, která pokud má hrát
                            za kolečka,
                            <ul>
                                <li>zamění v hracím poli 'x'↔'o',</li>
                                <li>na výsledek zavolá funkci, která zahraje křížek,</li>
                                <li>a ve výsledku opět zamění 'x'↔'o'.</li>
                            </ul>
                            Původní křížky a kolečka tak zůstanou na svých
                            místech, ale nově přidaný křížek se nahradí
                            za kolečko.
                        </div>
<pre>
def tah_pocitace(pole, symbol):
    if symbol == 'x':
        return tah_pocitace_x(pole)
    else:
        return zamen_xo(tah_pocitace_x(zamen_xo(pole)))
</pre>
                        <div>
                            Zkus napsat funkci <code>zamen_xo</code>.
                            Udělej v ní seznam jednotlivých znaků
                            (viz sekce Tvoření seznamů),
                            a pak ho převéď na řetězec pomocí
                            <code>join</code>.
                        </div>
<details class="solution notes"><h3>Řešení</h3>
<pre>
def zamen_xo(retezec):
    vysledek = []
    for znak in retezec:
        if znak == 'o':
            vysledek.append('x')
        elif znak == 'x':
            vysledek.append('o')
        else:
            vysledek.append(znak)
    return ''.join(vysledek)
</pre>
                        <div>
                            Prázdný oddělovač způsobí, že se jednotlivé
                            prvky seznamu „nalepí” těsně vedle sebe.
                        </div>
</details>
                        <h2>Seznamy a náhoda</h2>
                        <div>
                            Modul <code>random</code> obsahuje dvě funkce,
                            které se hodí k seznamům.
                            Jako <code>random.randrange</code>, obě mají něco
                            společného s náhodou.
                        </div>
                        <div>
                            Funkce <code>shuffle</code> seznam „zamíchá” –
                            všechny prvky náhodně popřehází.
                            Jako metoda <code>sort</code>, i funkce
                            <code>shuffle</code> nic nevrací.
                        </div>
<pre>
import random

balicek = []
for barva in '♠', '♥', '♦', '♣':
    for hodnota in list(range(2, 11)) + ['J', 'Q', 'K', 'A']:
        balicek.append(str(hodnota) + barva)
print(balicek)

random.shuffle(balicek)
print(balicek)
</pre>
                        <div>
                            A funkce <code>choice</code> ze seznamu vybere
                            jeden náhodný prvek.
                            S použitím seznamu tak můžeme výrazně zjednodušit
                            úvodní část naší staré hry kámen/nůžky/papír :
                        </div>
<pre>
import random
mozne_tahy = ['kámen', 'nůžky', 'papír']
tah_pocitace = random.choice(mozne_tahy)
</pre>
                        <section class="new">
                        <h2><i>N</i>-tice</h2>
                        <div>
                            Když už známe seznam, podívejme se na jeho
                            mladší sesrřičku: takzvanou <i>n</i>-tici
                            (angl. <em>tuple</em>).
                        </div>
                        <div>
                            <i>N</i>-tice, podobně jako seznam,
                            může obsahovat <i>n</i> prvků. 
                            <i>N</i>-tice se dvěma prvky je <em>dvojice</em>
                            (angl. <em>pair</em>); se třemi prvky
                            <em>trojice</em> (angl. <em>3-tuple</em>),
                            se čtyřmi <em>čtveřice</em> (angl. <em>4-tuple</em>),
                            atd.
                        </div>
                        <div class="note">
                            <small>
                                Existují i <i>n</i>-tice s jedním prvkem
                                (jednice?)
                                a nula prvky (prázdné n-tice, angl. <em>empty tuple</em>),
                                ale těmi se ze začátku nebudeme zabývat.
                            </small>
                        </div>
                        <div>
                            <i>N</i>-tice se tvoří jako seznamy, jen kolem sebe
                            nemají hranaté závorky.
                            Stačí čárky mezi prvky.
                        </div>
                        <div>
                            Chovají skoro stejně jako seznamy,
                            jen nejdou měnit.
                            Nemají tedy metody jako <code>append</code>
                            a <code>pop</code>, a nedá se jim přiřazovat
                            do prvků.
                            Dají se ale použít v cyklu <code>for</code>,
                            a dájí se z nich brát jednotlivé prvky.
                        </div>
<pre>
osoby = 'máma', 'teta', 'babička'
for osoba in osoby:
    print(osoba)
print('První je {}'.format(osoby[0]))
</pre>
                        <div>
                            Když chceme <i>n</i>-tici předat funkci,
                            narazíme na problém, že čárka odděluje jednotlivé
                            argumenty funkce.
                            V takových případech musíme <i>n</i>-tici
                            uzavřít do závorky, aby bylo jasné že jde o jednu
                            hodnotu (byť složenou).
                        </div>
<pre>
seznam_dvojic = []
for i in range(10):
    <span class="comment"># `append` bere jen jeden argument; dáme mu jednu dvojici</span>
    seznam_dvojic.append((i, i**2))
print(seznam_dvojic)
</pre>
                        <div>
                            <i>N</i>-tice se hodí, pokud chceme z funkce vrátit
                            víc než jednu hodnotu.
                            Prostě v příkazu <code>return</code> oddělíme
                            vracené hodnoty čárkou.
                            Vypadá to, že vracíme několik hodnot, ale
                            ve skutečnosti vrací jen jedna <i>n</i>-tice.
                        </div>
<pre>
def podil_a_zbytek(a, b):
    return a // b, a % b
</pre>
                        <div>
                            Python umí ještě jeden trik: pokud chceme přiřadit
                            do několika proměnných najednou, stačí je na levé
                            straně rovnítka oddělit čárkou, a na pravou stranu
                            dát nějakou „složenou” hodnotu – třeba právě
                            <i>n</i>-tici.
                        </div>
<pre>
podil, zbytek = podil_a_zbytek(12, 5)
</pre>
                        <div>
                            <i>N</i>-tice se k tomuto účelu hodí nejvíc, ale
                            jde to se všemi hodnotami, které jdou použít ve
                            <code>for</code>:
                        </div>
<pre>
x, o = 'xo'
jedna, dva, tri = [1, 2, 3]
</pre>
                        <h2>Funkce, které vracejí <i>n</i>-tice</h2>
                        <div>
                            <code>zip</code> je zajímavá funkce.
                            Používá se ve <code>for</code> cyklech, podobně
                            jako funkce <code>range</code> která „dává” čísla.
                        <div>
                        </div>
                            Když funkce <code>zip</code> dostane dva seznamy
                            (či jiné věci použitelné ve <code>for</code>),
                            „dává” dvojice, a to tak, že nejdřív spáruje
                            první prvek jednoho seznamu s prvním prvkem
                            druhého seznamu,
                            pak druhý s druhým, třetí s třetím a tak dál.
                        </div>
                        <div>
                            Hodí se to, když máme dva seznamy se stejnou
                            strukturou – příslušné prvky k sobě „patří”,
                            a chceme je zpracovávat společně:
                        </div>
<pre>
osoby = 'máma', 'teta', 'babička', 'vrah'
vlastnosti = 'hodná', 'milá', 'laskavá', 'zákeřný'
for osoba, vlastnost in zip(osoby, vlastnosti):
    print('{} je {}'.format(osoba, vlastnost))
</pre>
                        <div>
                            Když <code>zip</code> dostane tři seznamy,
                            bude tvořit trojice, ze čtyř seznamů nadělá
                            čtveřice, a tak dále.
                        </div>
                        <div>
                            Další funkce, která vrací dvojice, je
                            <code>enumerate</code>.
                            Jako argument bere seznam (či jinou věc použitelnou
                            ve <code>for</code>), a vždy spáruje index
                            (pořadí v seznamu) s příslušným prvkem.
                            Jako první tedy dá
                            (0, <em>první prvek seznamu</em>), potom
                            (1, <em>první prvek seznamu</em>),
                            (2, <em>třetí prvek seznamu</em>),
                            a tak dále.
                        </div>
<pre>
prvocisla = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

for i, prvocislo in enumerate(prvocisla):
    print('Pvočíslo č.{} je {}'.format(i, prvocislo))
</pre>
                        <h2>Kdy použít seznam, a kdy <i>n</i>-tici?</h2>
                        <div>
                            Seznamy se používají, když předem nevíme,
                            kolik v nich přesně bude hodnot,
                            nebo když je hodnot mnoho.
                            Například seznam slov ve větě,
                            seznam účastníků soutěže, seznam tahů ve hře,
                            nebo seznam karet v balíčku.
                            Oproti tomu <code>for pozdrav in 'Ahoj', 'Hello', 'Hola', 'Hei', 'SYN':</code>
                            používá <i>n</i>-tici.
                        </div>
                        <div>
                            <i>N</i>-tice se často používají na hodnoty
                            různých typů, kdy má každá „pozice”
                            v <i>n</i>-tici úplně jiný význam.
                            Například seznam můžeme použít na písmena abecedy,
                            ale dvojice index–hodnota z <code>enumerate</code>
                            je <i>n</i>-tice.
                        </div>
                        <div>
                            Seznamy i n-tice mají i technické limity:
                            <i>n</i>-tice nejdou měnit,
                            a až se naučíme pracovat se slovníky,
                            zjistíme že seznamy tam nepůjdou použít jako klíče.
                        </div>
                        <div>
                            Často ale není úplně jasné, který typ použít
                            – v takovém případě je to pravděpodobně jedno.
                            Řiď se instinktem :)
                        </div>
                        <h2>Vnořené seznamy</h2>
                        <div>
                            A perlička na konec!
                            Na začátku tohoto textu je napsáno, že v seznam
                            může obsahovat jakýkoli typ hodnot.
                            Samozřejmě může obsahovat i další seznamy:
                        </div>
<pre>
seznam_seznamu = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</pre>
                        <div>
                            Takový seznam se chová docela normálně – jdou
                            z něj třeba brát jednotlivé prvky
                            (které jsou ovšem taky seznamy):
                        </div>
<pre>
prvni_seznam = seznam_seznamu[0]
print(prvni_seznam)
</pre>
                        <div>
                            A protože jsou prvky samy seznamy,
                            můžeme mluvit o věcech jako „první prvek
                            druhého seznamu”:
                        </div>
<pre>
druhy_seznam = seznam_seznamu[1]
prvni_prvek_druheho_seznamu = druhy_seznam[0]
print(prvni_prvek_druheho_seznamu)
</pre>
                        <div>
                            A protože výraz <code>seznam_seznamu[1]</code>
                            označuje seznam, můžeme brát prvky přímo z něj:
                        </div>
<pre>
prvni_prvek_druheho_seznamu = (seznam_seznamu[1])[0]
</pre>
                        <div>
                            Neboli:
                        </div>
<pre>
prvni_prvek_druheho_seznamu = seznam_seznamu[1][0]
</pre>
                        <div>
                            A má tahle věc nějaké použití, ptáš se?
                            Stejně jako vnořené cykly <code>for</code>
                            nám umožnily vypsat tabulku, vnořené seznamy
                            nám umožní si tabulku „zapamatovat”.
                        </div>
<pre>
def vytvor_tabulku(velikost=11):
    seznam_radku = []
    for a in range(velikost):
        radek = []
        for b in range(velikost):
            radek.append(a * b)
        seznam_radku.append(radek)
    return seznam_radku

nasobilka = vytvor_tabulku()

print(nasobilka[2][3])
print(nasobilka[5][2])
print(nasobilka[8][7])

for radek in nasobilka:
    for cislo in radek:
        print(cislo, end=' ')
    print()
</pre>
                    </section>
                    </section>
                </section>
            </div>
            <div class="no-reveal footer">
                <div>pro PyLadies Brno napsal Petr Viktorin, 2014</div>
                <div>Licence: <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International</a></div>
            </div>
        </div>

        <script src="../reveal.js/lib/js/head.min.js"></script>
        <script src="../reveal.js/js/reveal.min.js"></script>
        <script type="text/javascript" src="../js/solutions.js"></script>
        <script type="text/javascript" src="../js/start_reveal.js"></script>

    </body>
</html>
